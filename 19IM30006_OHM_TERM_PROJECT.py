# -*- coding: utf-8 -*-
"""19IM30006_OHM_TERM_PROJECT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D1QbGZ-F0pAK3ir7d8A317aN_Tyd4VWi
"""

## NAME - Ayush Raj   Roll number - 19IM30006


import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from random import randint, random
from copy import deepcopy
import math

## FITNESS FUNCTION

def fitness(x,data):
    
    rd = 0.009    # return on deposit = 0.9% given
    rt = 0.01     # rate of transactions
    D = 60
    K = 0.15 
    delta = 0.0025
    beta = rd*D   # cost of demand deposit
    fitness = 0   # fitness
    
    for idx in range(len(x)):
        
        approval = x[idx]        
        if(approval):
            
            # lending rate
            rl = float(data.iloc[idx]['Interest'])
            
            # loan loss
            lambd = float(data.iloc[idx]['Loss'])
            
            # loan size
            L = float(data.iloc[idx]['Size'])
            
            # transaction cost
            T = (1-K)*D-L
            
            # loan cost
            loan_cost = L*delta
            
            # loan revenue
            loan_revenue = rl*L-lambd
            fitness += loan_revenue + T*rt - loan_cost
    
    fitness -= beta
    
    return fitness

# isvalid() function helps us validate that the loans given (L) satisfy the condition (1 ‚àí ùêæ)ùê∑ ‚â• ‚àëùêø.
def isvalid(x,data):
    
    D = 60 
    K = 0.15 
    L = 0 #total loan size
    for idx in range(len(x)):
        
        approval = x[idx]
        
        if(approval):
                        
            # loan size
            L += float(data.iloc[idx]['Size'])
    return L<=(1-K)*D

# genetic algorithm
def GA():
    
    data = pd.read_csv("Project_Data.csv")
    
    # number of genes
    n = data.shape[0]
    
    pc = 0.8 # crossover probability
    pm = 0.006 # mutation probability
    popn = 50
    generations = 60
    
    # initializing pool of chromosomes
    pool = [] 
    
    for num in range(popn):
        chrom = [randint(0,1) for i in range(n)]
        
        while(not isvalid(chrom,data)):
            chrom = [randint(0,1) for i in range(n)]
        
        pool.append(chrom)

    
    best_fit_g = 0
    best_soln = []
    best_soln_ch = []
    Generation=[]
    for gen in range(generations+1):
        
        cum_fitn = []
        tot_fit = 0
        best_fit_l = 0
        
        for chrom in pool:
            
            fitn = fitness(chrom,data)
            tot_fit += fitn
            cum_fitn.append(tot_fit)
            
            # local best fitness
            best_fit_l = max(best_fit_l,fitn)
            
            if(best_fit_l == fitn):
                best_sol = chrom
            
            # global best fitness
            best_fit_g = max(best_fit_g,best_fit_l)
        
            if(best_fit_g==best_fit_l):
                glob_best_soln = best_sol
        
        best_soln.append(best_fit_l)
        best_soln_ch.append(best_sol)
        Generation.append(gen)
         
        new_pool = []
        
        for num in range(int(popn/2)):
            idx1 = 0
            idx2 = 0
            
            r1 = random()
            for i1 in range(len(cum_fitn)):
                if(r1<cum_fitn[i1]/tot_fit):
                    idx1 = i1
                    break
                
            r2 = random()
            for i2 in range(len(cum_fitn)):
                if(r2<cum_fitn[i2]/tot_fit):
                    idx2 = i2
                    break

            while(idx1==idx2):

                r2 = random()
                for i2 in range(len(cum_fitn)):
                    if(r2<cum_fitn[i2]/tot_fit):
                        idx2 = i2
                        break
            
            c1 = deepcopy(pool[idx1])
            c2 = deepcopy(pool[idx2])
            
            invalid = True
            while(invalid):
                rn = random()
                
                # crossover
                if(rn<pc):
                    point = randint(0,n-1)
                    temp = c2[point:]
                    c2[point:] = c1[point:]
                    c1[point:] = temp
                # mutation
                m1 = random()
                m2 = random()
                
                if(m1<pm):
                
                    point = randint(0,n-1)
                    c1[point] = 1 - c1[point]
                
                if(m2<pm):
                    
                    point = randint(0,n-1)
                    c2[point] = 1 - c2[point]
                    
                if(isvalid(c1,data) and isvalid(c2,data)):
                    invalid = False
            
            new_pool.append(c1)
            new_pool.append(c2)
            
        pool = deepcopy(new_pool)
        print("Generation:",gen,"SOLUTION",glob_best_soln,"FITNESS",best_fit_g) 
    print("Global Best:",glob_best_soln,best_fit_g)
    
    return best_soln,best_soln_ch,Generation
best_fitness,best_chromosome,Generations = GA()

plt.plot(Generations,best_fitness)
plt.xlabel("Generation")
plt.ylabel("Solution")
plt.title("Genetic Algorithm")
plt.show()

# simulated annealing
def SA():
    
    data = pd.read_csv('Project_Data.csv')
    
    T0 = 0 # initial temperature
    
    ## generating 10 random solution to calculte initial temperature
    for num in range(10):    
        
        x = [randint(0,1) for i in range(10)]
        while(not isvalid(x,data)):
            x = [randint(0,1) for i in range(10)]
        
        T0 += fitness(x,data)/10
    
    Tf = T0/20 # final temperature
    
    ## cooling: T' = T - cool
    cool = T0/20
    
    n = 100 # number of iterations

    # initial solution is x currently and temperature is T0
    T = T0
    Temp = []
    best_fits = []
    best_sols = []
    
    while(T>=Tf):
        
        best_fit = 0 # stores best fitness at each temperature
        for it in range(n):
            
            ## creating new solution
            
            # for storing new solution
            y = [0 for i in range(len(x))]

            invalid = True
            while(invalid):
                
                for idx in range(len(x)): 
                
                    rand_num = random()
                    
                    if(rand_num>0.5):
                        
                        y[idx] = 1 - x[idx]
                    
                    else:
                        
                        y[idx] = x[idx]
                
                if(isvalid(y,data)):
                    invalid = False
            
            
                    
            prev_fit = fitness(x,data)
            cur_fit = fitness(y,data)
            
            
            delta = cur_fit-prev_fit
            
            # accepting
            if(delta>=0):
                x = y # updating better solution
            else:
                rn = random()
                if(math.exp(delta/T)>rn):
                    x = y
            
            if( fitness(x,data) > best_fit ):
                
                best_fit = fitness(x,data)
                best_sol = x
        Temp.append(T)
        best_fits.append(best_fit)
        best_sols.append(best_sol)    

        print("TEMPERATURE",T,"SOLUTION",best_sol,"FITNESS",best_fit)       
        T = T - cool
        
    return best_fits, best_sols,Temp
best_fitness2,best_chromosome2,Temp2 = SA()

plt.plot(Temp2,best_fitness2)
plt.xlabel("Temperature")
plt.ylabel("Solution")
plt.title("Simulated Annealing")
plt.show()